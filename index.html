<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Choo&#39;blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Choo&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Choo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Choo'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Choo'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/" class="post-title-link" itemprop="url">正则表达式基本规则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-26 11:44:41 / 修改时间：16:29:59" itemprop="dateCreated datePublished" datetime="2021-04-26T11:44:41+08:00">2021-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则基本概念"><a href="#正则基本概念" class="headerlink" title="正则基本概念"></a>正则基本概念</h1><ul>
<li>正则基础规则<ul>
<li>正则支持任意朴素字符<ul>
<li><code>hello world</code></li>
</ul>
</li>
<li>正则支持子正则的平行拼接<ul>
<li><code>^h(a|e)?llo\sworld\b.*$</code></li>
</ul>
</li>
</ul>
</li>
<li>字符模式 (匹配单个字符串)<ul>
<li>字符组<ul>
<li>[abc] a或b或c (匹配这些字符)</li>
<li>[^abc]不是 a 或 b 或 c 的其他字符（排除这些字符）</li>
<li>[a-z] 匹配a-z</li>
<li>[g-zA-F1-5] 匹配小写 g 到 z、大写 A 到 F、数字 1 到 5</li>
</ul>
</li>
<li>转义字符<ul>
<li><code>.</code>任意字符</li>
<li><code>\s</code> 空格</li>
<li><code>\S</code> 非空格</li>
<li><code>\d</code> 数字</li>
<li><code>\D</code> 非数字</li>
<li><code>\w</code> 字符(字母+数字+下划线)</li>
<li><code>\W</code> 非字符</li>
<li><code>\t</code> tab</li>
<li><code>\n</code> 换行</li>
<li><code>\r</code> 回车</li>
</ul>
</li>
<li>捕获和引用<ul>
<li>捕获组()<ul>
<li>(hallo) 匹配 hallo，且捕获括号内内容</li>
<li>（捕获组的捕获顺序，按左括号从左到右为 1234…）</li>
</ul>
</li>
<li>正则内引用 \1<ul>
<li>(a,b).\1匹配 ‘ab,ab’</li>
</ul>
</li>
<li>结果引用 (replace第二参数的特殊字符)<ul>
<li><code>$1</code> 按捕获顺序，例如：<code>abcd.replace(/(ab)/, &#39;$1,&#39;)</code></li>
<li><code>$&amp;</code> 匹配的整个子串</li>
<li><em>$`</em> 匹配子串的左边文本（键盘左侧的反引号）</li>
<li><em>$’</em> 匹配子串的右边文本（键盘右侧的引号）</li>
<li><em>$$</em> 转义 $</li>
</ul>
</li>
<li>组合模式（正则串的单次组合）<ul>
<li>或 <code>｜</code><ul>
<li><code>h(a|e)llo</code> 匹配 hallo 或 hello（切换匹配（并捕获））</li>
</ul>
</li>
<li>量词（左边的 a 可以是任意正则模式）<ul>
<li><code>a+</code> 匹配 ‘a、’aa’（至少一个）</li>
<li><code>a*</code> 匹配 ‘’、’aaa’（零或多个）</li>
<li><code>a?</code> 匹配 ‘’， ‘a’ (零或一个)</li>
<li><code>a&#123;3&#125;</code> 匹配<code>aaa</code> (精确的N个)</li>
<li><code>a&#123;3,&#125;</code> 匹配 ‘aaa’ 到 ‘aaaaaaa…’ (至少n个)</li>
<li><code>a&#123;3,6&#125;</code> 匹配 ‘aaa’ 到 ‘aaaaaa’（N 到 M 个）</li>
</ul>
</li>
<li>非贪婪 (惰性)<ul>
<li><code>a&#123;3,6&#125;?</code> 匹配 ‘aaa’（非贪婪：匹配到越少越好）</li>
</ul>
</li>
</ul>
</li>
<li>位置模式(位置不是字符，不具有宽度)<ul>
<li>转义字符<ul>
<li><code>^</code> 行开头</li>
<li><code>$</code> 行结尾</li>
<li><code>\b</code> 单词边界</li>
<li><code>\B</code> 非单词边界</li>
</ul>
</li>
<li>断言 (其中的 a 可以是任意子正则)<ul>
<li><code>(?=a)</code> Positive lookahead，右边匹配</li>
<li><code>(?!a)</code> Negative lookahead，右边不匹配</li>
<li><code>(?&lt;=a)</code> Positive lookbehind，左边匹配</li>
<li><code>(?&lt;!a)</code> Negative lookbehind，左边不匹配</li>
</ul>
</li>
</ul>
</li>
<li>flags<ul>
<li><code>g</code> global，全部（多次）匹配</li>
<li><code>i</code> case-insensitive，忽略大小写</li>
<li><code>m</code> multi-line，多行匹配</li>
<li><code>u</code> unicode，开启 unicode 支持</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">函数组合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 17:36:06" itemprop="dateCreated datePublished" datetime="2021-04-25T17:36:06+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 11:16:08" itemprop="dateModified" datetime="2021-04-26T11:16:08+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h1><p>这就是<code>组合</code>(compose)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f,g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>f</code> 和 <code>g</code> 都是函数，<code>x</code>是在他们之间通过”管道”传输的值</p>
<p><code>组合</code>看起来像是在饲养函数。你就是饲养员，选择两个有特点又遭你喜欢的函数，让它们结合，产下一个崭新的函数。组合的用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toUpperCase(); &#125;;</span><br><span class="line"><span class="keyword">var</span> exclaim = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="string">&#x27;!&#x27;</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shout = compose(exclaim, toUpperCase);</span><br><span class="line"></span><br><span class="line">shout(<span class="string">&quot;send in the clowns&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="应用compose函数"><a href="#应用compose函数" class="headerlink" title="应用compose函数"></a>应用compose函数</h4><p>假定有这样一个需求：对一个给定的数字四舍五入求值，数字为字符型。</p>
<p>常规实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="string">&#x27;3.56&#x27;</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">parseFloat</span>(n)</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Math</span>.round(data) <span class="comment">// =&gt; 4 最终结果</span></span><br></pre></td></tr></table></figure>

<p>用compose函数改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="string">&#x27;3.56&#x27;</span></span><br><span class="line"><span class="keyword">let</span> number = compose(<span class="built_in">Math</span>.round,<span class="built_in">parseFloat</span>)</span><br><span class="line"><span class="keyword">let</span> result = number(n); <span class="comment">// =&gt;4 最终结果</span></span><br></pre></td></tr></table></figure>

<h2 id="函数组合应用"><a href="#函数组合应用" class="headerlink" title="函数组合应用"></a>函数组合应用</h2><p>考虑一个小功能：将数组最后一个元素大写，假设 <code>log</code> <code>head</code> <code>reverse</code> <code>toUpperCase</code> 函数存在</p>
<p>命令式的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log(toUpperCase(head(reverse(arr))))</span><br></pre></td></tr></table></figure>

<p>面向对象的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.reverse()</span><br><span class="line">  .head()</span><br><span class="line">  .toUpperCase()</span><br><span class="line">  .log()</span><br></pre></td></tr></table></figure>

<p>链式调用看起来顺眼多了，然而问题在于，原型链上可供我们链式调用的函数是有限的，而需求是无限的 ，这限制了我们的逻辑表现力。</p>
<p>现在通过组合，我们如何实现之前的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> upperLastItem = compose(log, toUpperCase, head, reverse);</span><br></pre></td></tr></table></figure>

<p>通过参数我们可以很清晰的看出发生了 uppderLastItem 做了什么，它完成了一套流水线，所有经过这条流水线的参数都会经历：<code>reverse -&gt; head -&gt; toUpperCase -&gt; log</code> 这些函数的加工，最后生成结果。</p>
<h3 id="函数组合的好处"><a href="#函数组合的好处" class="headerlink" title="函数组合的好处"></a>函数组合的好处</h3><p>函数组合的好处显而易见，它让代码变得简单而富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合方式 1</span></span><br><span class="line"><span class="keyword">const</span> last = compose(head, reverse);</span><br><span class="line"><span class="keyword">const</span> shout = compose(log, toUpperCase);</span><br><span class="line"><span class="keyword">const</span> shoutLast = compose(shout, last);</span><br><span class="line"><span class="comment">// 组合方式 2</span></span><br><span class="line"><span class="keyword">const</span> lastUppder = compose(toUpperCase, head, reverse);</span><br><span class="line"><span class="keyword">const</span> logLastUpper = compose(log, lastUppder);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/%E6%9F%AF%E9%87%8C%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/%E6%9F%AF%E9%87%8C%E5%8C%96/" class="post-title-link" itemprop="url">柯里化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:23:39 / 修改时间：18:23:49" itemprop="dateCreated datePublished" datetime="2021-04-23T18:23:39+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="不可或缺的curry"><a href="#不可或缺的curry" class="headerlink" title="不可或缺的curry"></a>不可或缺的curry</h4><p>curry的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数、</p>
<p>你可以一次性地调用curry函数，也可以每次只传一个参数分多次调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数使这类函数的定义和调用更加容易。</p>
<p>下面是一下curry函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>).curry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = curry(<span class="function"><span class="keyword">function</span>(<span class="params">what, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.match(what);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replace = curry(<span class="function"><span class="keyword">function</span>(<span class="params">what, replacement, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(what, replacement);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filter = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, ary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ary.filter(f);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, ary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ary.map(f);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">match(<span class="regexp">/\s+/g</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">// [ &#x27; &#x27; ]</span></span><br><span class="line"></span><br><span class="line">match(<span class="regexp">/\s+/g</span>)(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">// [ &#x27; &#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasSpaces = match(<span class="regexp">/\s+/g</span>);</span><br><span class="line"><span class="comment">// function(x) &#123; return x.match(/\s+/g) &#125;</span></span><br><span class="line"></span><br><span class="line">hasSpaces(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="comment">// [ &#x27; &#x27; ]</span></span><br><span class="line"></span><br><span class="line">hasSpaces(<span class="string">&quot;spaceless&quot;</span>);</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">filter(hasSpaces, [<span class="string">&quot;tori_spelling&quot;</span>, <span class="string">&quot;tori amos&quot;</span>]);</span><br><span class="line"><span class="comment">// [&quot;tori amos&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findSpaces = filter(hasSpaces);</span><br><span class="line"><span class="comment">// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(/\s+/g) &#125;) &#125;</span></span><br><span class="line"></span><br><span class="line">findSpaces([<span class="string">&quot;tori_spelling&quot;</span>, <span class="string">&quot;tori amos&quot;</span>]);</span><br><span class="line"><span class="comment">// [&quot;tori amos&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> noVowels = replace(<span class="regexp">/[aeiou]/ig</span>);</span><br><span class="line"><span class="comment">// function(replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> censored = noVowels(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// function(x) &#123; return x.replace(/[aeiou]/ig, &quot;*&quot;) &#125;</span></span><br><span class="line"></span><br><span class="line">censored(<span class="string">&quot;Chocolate Rain&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;Ch*c*l*t* R**n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p>
<p>个人觉得：“柯里化”就像某些官员的把戏，官员要弄7个老婆，碍于国策（一夫一妻）以及年老弟衰，表面上就1个老婆，实际上剩下的6个暗地里消化。代码表示就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn 指官员消化老婆的手段</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// args 指的是那个合法老婆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 已经有的老婆和新搞定的老婆们合成一体，方便控制</span></span><br><span class="line">        <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="comment">// 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下为官员如何搞定7个老婆的测试</span></span><br><span class="line"><span class="comment">// 获得合法老婆</span></span><br><span class="line"><span class="keyword">var</span> getWife = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allWife = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆</span></span><br><span class="line">    <span class="built_in">console</span>.log(allWife.join(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">&#125;, <span class="string">&quot;合法老婆&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得其他6个老婆</span></span><br><span class="line">getWife(<span class="string">&quot;大老婆&quot;</span>,<span class="string">&quot;小老婆&quot;</span>,<span class="string">&quot;俏老婆&quot;</span>,<span class="string">&quot;刁蛮老婆&quot;</span>,<span class="string">&quot;乖老婆&quot;</span>,<span class="string">&quot;送上门老婆&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换一批老婆</span></span><br><span class="line">getWife(<span class="string">&quot;超越韦小宝的老婆&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="柯里化的作用"><a href="#柯里化的作用" class="headerlink" title="柯里化的作用"></a>柯里化的作用</h3><h4 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h4><p>参数复用”上面已经展示过了，官员老婆的例子就是，无论哪个官员，都是需要一个合法老婆；通过柯里化过程，getWife()无需添加这个多余的“合法老婆”参数</p>
<h4 id="提前返回"><a href="#提前返回" class="headerlink" title="提前返回"></a>提前返回</h4><p>“提前返回”，很常见的一个例子，兼容现代浏览器以及IE浏览器的事件添加方法。我们正常情况可能会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn, capture</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        el.addEventListener(type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            fn.call(el, e);</span><br><span class="line">        &#125;, capture);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        el.attachEvent(<span class="string">&quot;on&quot;</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            fn.call(el, e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，(eg. IE6/IE7)都会走一遍if…else if …，其实只要一次判定就可以了，怎么做？–柯里化。改为下面这样子的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, sType, fn, capture</span>) </span>&#123;</span><br><span class="line">            el.addEventListener(sType, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;, (capture));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, sType, fn, capture</span>) </span>&#123;</span><br><span class="line">            el.attachEvent(<span class="string">&quot;on&quot;</span> + sType, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>初始addEvent的执行其实值实现了部分的应用（只有一次的if…else if…判定），而剩余的参数应用都是其返回函数实现的，典型的柯里化。</p>
<h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像我们js中经常使用的bind，实现的机制就是Currying.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/%E7%BA%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/%E7%BA%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84/" class="post-title-link" itemprop="url">纯函数的好处</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:22:49 / 修改时间：18:23:23" itemprop="dateCreated datePublished" datetime="2021-04-23T18:22:49+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="纯函数的概念"><a href="#纯函数的概念" class="headerlink" title="纯函数的概念"></a>纯函数的概念</h4><blockquote>
<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用</p>
</blockquote>
<p>比如 <strong>slice</strong> 和 <strong>splice</strong>，这两个函数的作用并无二致——但是注意，它们各自的方式却大不同，但不管怎么说作用还是一样的。我们说 <strong>slice</strong> 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 <strong>splice</strong> 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了</p>
<p>在函数式编程中，我们讨厌这种会改变数据的笨函数。我们追求的是那种可靠的，每次都能返回同样结果的函数，而不是像 splice 这样每次调用后都把数据弄得一团糟的函数，这不是我们想要的。</p>
<p>来看看另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不纯的</span></span><br><span class="line"><span class="keyword">var</span> minimum = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age &gt;= minimum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯的</span></span><br><span class="line"><span class="keyword">var</span> checkAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> minimum = <span class="number">21</span>;</span><br><span class="line">  <span class="keyword">return</span> age &gt;= minimum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在不纯的版本中，checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。</p>
<h3 id="追求纯的理由"><a href="#追求纯的理由" class="headerlink" title="追求纯的理由"></a>追求纯的理由</h3><h4 id="可缓存性-Cacheable"><a href="#可缓存性-Cacheable" class="headerlink" title="可缓存性 (Cacheable)"></a>可缓存性 (Cacheable)</h4><p>首先，纯函数总能够根据输入来做缓存。实现缓存的一种典型方式是 memoize 技术:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">    cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[arg_str];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squareNumber  = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x; &#125;);</span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//=&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>); <span class="comment">// 从缓存中读取输入值为 4 的结果</span></span><br><span class="line"><span class="comment">//=&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//=&gt; 25</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>); <span class="comment">// 从缓存中读取输入值为 5 的结果</span></span><br><span class="line"><span class="comment">//=&gt; 25</span></span><br></pre></td></tr></table></figure>

<p>值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pureHttpCall = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> $.getJSON(url, params); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="可移植性-自文档化"><a href="#可移植性-自文档化" class="headerlink" title="可移植性/自文档化"></a>可移植性/自文档化</h4><p>纯函数是完全自给自足的，它需要的所有东西都能轻易获得。更易于观察和理解，没有偷偷摸摸的小动作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不纯的</span></span><br><span class="line"><span class="keyword">var</span> signUp = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = saveUser(attrs);</span><br><span class="line">  welcomeUser(user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveUser = <span class="function"><span class="keyword">function</span>(<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = Db.save(attrs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> welcomeUser = <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    Email(user, ...);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯的</span></span><br><span class="line"><span class="keyword">var</span> signUp = <span class="function"><span class="keyword">function</span>(<span class="params">Db, Email, attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = saveUser(Db, attrs);</span><br><span class="line">    welcomeUser(Email, user);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveUser = <span class="function"><span class="keyword">function</span>(<span class="params">Db, attrs</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> welcomeUser = <span class="function"><span class="keyword">function</span>(<span class="params">Email, user</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子表明，纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 signUp 的签名就可以看出，它将要用到 <code>Db</code>、<code>Email</code>和 <code>attrs</code>，这在最小程度上给了我们足够多的信息</p>
<h4 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h4><p>纯函数让测试更加容易。我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/Vue-Router%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/Vue-Router%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">Vue Router：如何实现一个前端路由</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:21:55 / 修改时间：18:22:13" itemprop="dateCreated datePublished" datetime="2021-04-23T18:21:55+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在我们创建 router 对象的时候，会创建一个 history 对象，前面提到 Vue Router 支持三种模式，这里我们重点分析 HTML5 的 history 的模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWebHistory</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  base = normalizeBase(base)</span><br><span class="line">  <span class="keyword">const</span> historyNavigation = useHistoryStateNavigation(base)</span><br><span class="line">  <span class="keyword">const</span> historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">delta, triggerListeners = <span class="literal">true</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!triggerListeners)</span><br><span class="line">      historyListeners.pauseListeners()</span><br><span class="line">    history.go(delta)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> routerHistory = assign(&#123;</span><br><span class="line">    <span class="comment">// it&#x27;s overridden right after</span></span><br><span class="line">    location: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    base,</span><br><span class="line">    go,</span><br><span class="line">    createHref: createHref.bind(<span class="literal">null</span>, base),</span><br><span class="line">  &#125;, historyNavigation, historyListeners)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(routerHistory, <span class="string">&#x27;location&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function">() =&gt;</span> historyNavigation.location.value,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(routerHistory, <span class="string">&#x27;state&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function">() =&gt;</span> historyNavigation.state.value,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> routerHistory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 routerHistory 对象而言，它有两个重要的作用，一个是路径的切换，一个是监听路径的变化。</p>
<p>其中，路径切换主要通过 historyNavigation 来完成的，它是 useHistoryStateNavigation 函数的返回值，我们来看它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useHistoryStateNavigation</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; history, location &#125; = <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> currentLocation = &#123;</span><br><span class="line">    value: createCurrentLocation(base, location),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> historyState = &#123; <span class="attr">value</span>: history.state &#125;</span><br><span class="line">  <span class="keyword">if</span> (!historyState.value) &#123;</span><br><span class="line">    changeLocation(currentLocation.value, &#123;</span><br><span class="line">      back: <span class="literal">null</span>,</span><br><span class="line">      current: currentLocation.value,</span><br><span class="line">      forward: <span class="literal">null</span>,</span><br><span class="line">      position: history.length - <span class="number">1</span>,</span><br><span class="line">      replaced: <span class="literal">true</span>,</span><br><span class="line">      scroll: <span class="literal">null</span>,</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeLocation</span>(<span class="params">to, state, replace</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = createBaseLocation() +</span><br><span class="line">      <span class="comment">// preserve any existing query when base has a hash</span></span><br><span class="line">      (base.indexOf(<span class="string">&#x27;#&#x27;</span>) &gt; -<span class="number">1</span> &amp;&amp; location.search</span><br><span class="line">        ? location.pathname + location.search + <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        : base) +</span><br><span class="line">      to</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      history[replace ? <span class="string">&#x27;replaceState&#x27;</span> : <span class="string">&#x27;pushState&#x27;</span>](state, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">      historyState.value = state</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      warn(<span class="string">&#x27;Error with push/replace State&#x27;</span>, err)</span><br><span class="line">      location[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">to, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> state = assign(&#123;&#125;, history.state, buildState(historyState.value.back,</span><br><span class="line">      <span class="comment">// keep back and forward entries but override current position</span></span><br><span class="line">      to, historyState.value.forward, <span class="literal">true</span>), data, &#123; <span class="attr">position</span>: historyState.value.position &#125;)</span><br><span class="line">    changeLocation(to, state, <span class="literal">true</span>)</span><br><span class="line">    currentLocation.value = to</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">to, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentState = assign(&#123;&#125;,</span><br><span class="line">      historyState.value, history.state, &#123;</span><br><span class="line">        forward: to,</span><br><span class="line">        scroll: computeScrollPosition(),</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">if</span> ( !history.state) &#123;</span><br><span class="line">      warn(<span class="string">`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n`</span> +</span><br><span class="line">        <span class="string">`history.replaceState(history.state, &#x27;&#x27;, url)\n\n`</span> +</span><br><span class="line">        <span class="string">`You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    changeLocation(currentState.current, currentState, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> state = assign(&#123;&#125;, buildState(currentLocation.value, to, <span class="literal">null</span>), &#123; <span class="attr">position</span>: currentState.position + <span class="number">1</span> &#125;, data)</span><br><span class="line">    changeLocation(to, state, <span class="literal">false</span>)</span><br><span class="line">    currentLocation.value = to</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    location: currentLocation,</span><br><span class="line">    state: historyState,</span><br><span class="line">    push,</span><br><span class="line">    replace</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回的 push 和 replace 函数，会添加给 routerHistory 对象上，因此当我们调用 routerHistory.push 或者是 routerHistory.replace 方法的时候实际上就是在执行这两个函数。</p>
<p>push 和 replace 方法内部都是执行了 changeLocation 方法，该函数内部执行了浏览器底层的 history.pushState 或者 history.replaceState 方法，会向当前浏览器会话的历史堆栈中添加一个状态，这样就在不刷新页面的情况下修改了页面的 URL。</p>
<p>我们使用这种方法修改了路径，这个时候假设我们点击浏览器的回退按钮回到上一个 URL，这需要恢复到上一个路径以及更新路由视图，因此我们还需要监听这种 history 变化的行为，做一些相应的处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/Vue3-0-vnode%E5%88%B0%E7%9C%9F%E5%AE%9EDOM%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/Vue3-0-vnode%E5%88%B0%E7%9C%9F%E5%AE%9EDOM%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">Vue3.0: vnode到真实DOM转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:18:02 / 修改时间：18:18:12" itemprop="dateCreated datePublished" datetime="2021-04-23T18:18:02+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Vue.js 中，组件是一个非常重要的概念，整个应用的页面都是通过组件渲染来实现的</p>
<p>首先，组件是一个抽象的概念，它是对一棵 DOM 树的抽象，我们在页面中写一个组件节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello-world&gt;&lt;/hello-world&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码并不会在页面上渲染一个<code>&lt;hello-world&gt;</code>标签，而他具体渲染成什么，取决于你怎么编写HelloWorld组件的模版。</p>
<p>所以，从表现上来看，组件的模板决定了组件生成的 DOM 标签，而在 Vue.js 内部，一个组件想要真正的渲染生成 DOM，还需要经历<strong>“创建 vnode - 渲染 vnode - 生成 DOM” 这几个步骤</strong></p>
<h4 id="应用程序初始化"><a href="#应用程序初始化" class="headerlink" title="应用程序初始化"></a>应用程序初始化</h4><p>一个组件可以通过“模板加对象描述”的方式创建，组件创建好以后是如何被调用并初始化的呢？因为整个组件树是由根组件开始渲染的，为了找到根组件的渲染入口，我们需要从应用程序的初始化过程开始分析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue.js 2.x 中，初始化一个应用的方式如下</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue.js 3.0 中，初始化一个应用的方式如下</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，Vue.js 3.0 初始化应用的方式和 Vue.js 2.x 差别并不大，本质上都是把 App 组件挂载到 id 为 app 的 DOM 节点上。</p>
<p>但是，在 Vue.js 3.0 中还导入了一个 createApp，其实这是个入口函数，它是 Vue.js 对外暴露的一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = (<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 app 对象</span></span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app</span><br><span class="line">  <span class="comment">// 重写 mount 方法</span></span><br><span class="line">  app.mount = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出 createApp 主要做了两件事情：创建 app 对象和重写 app.mount 方法。</p>
<h4 id="1-创建app对象"><a href="#1-创建app对象" class="headerlink" title="1.创建app对象"></a>1.创建app对象</h4><p>首先，我们使用 ensureRenderer().createApp() 来创建 app 对象 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br></pre></td></tr></table></figure>

<p>其中 ensureRenderer() 用来创建一个渲染器对象，它的内部代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br></pre></td></tr></table></figure>

<p>其中ensureRenderer()用来创建一个渲染器对象，它的内部代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法</span></span><br><span class="line"><span class="keyword">const</span> rendererOptions = &#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  ...nodeOps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderer || (renderer = createRenderer(rendererOptions))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseCreateRenderer(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 组件渲染的核心逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    createApp: createAppAPI(render)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>(<span class="params">render</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// createApp createApp 方法接受的两个参数：根组件的对象和 prop</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = &#123;</span><br><span class="line">      _component: rootComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      <span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br><span class="line">        <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line">        render(vnode, rootContainer)</span><br><span class="line">        app._container = rootContainer</span><br><span class="line">        <span class="keyword">return</span> vnode.component.proxy</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里先用ensureRenderer()来延时创建渲染器，这样做的好处是当用户只依赖响应式包的时候，就不会创建渲染器，因此可以通过tree-shaking的方式移除核心渲染逻辑相关的代码</p>
<p>在 Vue.js 3.0 内部通过 createRenderer 创建一个渲染器，这个渲染器内部会有一个 createApp 方法，它是执行 createAppAPI 方法返回的函数，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象，它会提供 mount 方法，这个方法是用来挂载组件的。</p>
<h3 id="核心渲染流程：创建-vnode-和渲染-vnode"><a href="#核心渲染流程：创建-vnode-和渲染-vnode" class="headerlink" title="核心渲染流程：创建 vnode 和渲染 vnode"></a>核心渲染流程：创建 vnode 和渲染 vnode</h3><h4 id="1-创建vnode"><a href="#1-创建vnode" class="headerlink" title="1.创建vnode"></a>1.创建vnode</h4><p>首先，是创建vnode的过程</p>
<p>vnode本质上是用来描述DOM的Javascript对象，它在Vue.js 中可以描述不同类型的节点，比如普通元素节点、组件节点等。</p>
<p>什么是普通元素节点呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100px;height:50px&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以用vnode这样表示<code>button</code>标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">  type: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">  props: &#123; </span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;btn&#x27;</span>,</span><br><span class="line">    style: &#123;</span><br><span class="line">      width: <span class="string">&#x27;100px&#x27;</span>,</span><br><span class="line">      height: <span class="string">&#x27;50px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: <span class="string">&#x27;click me&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，type 属性表示 DOM 的标签类型，props 属性表示 DOM 的一些附加信息，比如 style 、class 等，children 属性表示 DOM 的子节点，它也可以是一个 vnode 数组，只不过 vnode 可以用字符串表示简单的文本 。</p>
<p>什么是组件节点呢？其实， vnode 除了可以像上面那样用于描述一个真实的 DOM，也可以用来描述组件。</p>
<p>我们先在模板中引入一个组件标签 <custom-component>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-component</span> <span class="attr">msg</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以用 vnode 这样表示 <custom-component> 组件标签：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CustomComponent = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义组件对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">  type: CustomComponent,</span><br><span class="line">  props: &#123; </span><br><span class="line">    msg: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件 vnode 其实是对抽象事物的描述，这是因为我们并不会在页面上真正渲染一个 <custom-component> 标签，而是渲染组件内部定义的 HTML 标签。</p>
<p><strong>那么 vnode 有什么优势呢？为什么一定要设计 vnode 这样的数据结构呢？</strong></p>
<p>首先是抽象，引入vnode，可以把渲染过程抽象化，从而使得组件的抽象能力也得到提升</p>
<p>其次是跨平台，因为patch vnode的过程不同平台可以有自己的实现，基于vnode再做服务端渲染、weex平台、小程序的平台的渲染都变得容易很多</p>
<p>使用vnode并不意味着不用操作DOM了，很多人会误以为vnode的性能一定比手动操作原生DOM好，这个其实不一定。</p>
<p>因为，首先这种基于vnode实现的MVVM框架，在每次render to vnode的过程中，渲染组件会有一定的javascript耗时，特别是大组件，比如一个1000 * 10的Table组件，render to vnode的过程会遍历1000 * 10次去创建内部cell vnode，整个耗时就会变得特别常，加上patch vnode的过程也会有一定的耗时，当我们去更新组件的时候，用户会感觉到明显的卡顿。虽然diff算法在减少DOM操作方面足够优秀，但最终还是免不了操作DOM，所以说性能并不是vnode的优势</p>
<p><strong>那么，Vue.js 内部是如何创建这些 vnode 的呢？</strong></p>
<p>回顾，app.mount函数的实现，内部是通过createVNode函数创建了根组件的vnode：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br></pre></td></tr></table></figure>

<p>其实createVNode做的事情很简单，就是对props做标准化处理、对vnode的类型信息编码、创建vnode对象，标准化子节点children</p>
<h4 id="渲染vnode"><a href="#渲染vnode" class="headerlink" title="渲染vnode"></a>渲染vnode</h4><p>回顾app.mount函数的实现，内部通过执行这段代码去渲染创建好的vnode:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render(vnode, rootContainer)</span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁组件</span></span><br><span class="line">    <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">      unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或者更新组件</span></span><br><span class="line">    patch(container._vnode || <span class="literal">null</span>, vnode, container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">  container._vnode = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个渲染函数render的实现很简单，如果它的第一个参数vnode为空，则执行销毁组件的逻辑，否则执行创建或者更新组件的逻辑</p>
<p>patch 本意是打补丁的意思，这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM</p>
<p>在创建的过程中，patch 函数接受多个参数</p>
<ul>
<li>第一个参数 n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程；</li>
<li>第二个参数 n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑；</li>
<li>第三个参数 container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。</li>
</ul>
<p>对于渲染的节点，我们这里重点关注两种类型节点的渲染逻辑：对组件的处理和对普通 DOM 元素的处理。</p>
<p>先来看对组件的处理。由于初始化渲染的是 App 组件，它是一个组件 vnode，所以我们来看一下组件的处理逻辑是怎样的。首先是用来处理组件的 processComponent 函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = <span class="function">(<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 挂载组件</span></span><br><span class="line">   mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新组件</span></span><br><span class="line">    updateComponent(n1, n2, parentComponent, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的逻辑很简单，如果 n1 为 null，则执行挂载组件的逻辑，否则执行更新组件的逻辑。</p>
<p>我们接着来看挂载组件的 mountComponent 函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent = <span class="function">(<span class="params">initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  setupComponent(instance)</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，挂载组件函数 mountComponent 主要做三件事情：创建组件实例、设置组件实例、设置并运行带副作用的渲染函数。</p>
<p>首先是创建组件实例，Vue.js 3.0 虽然不像 Vue.js 2.x 那样通过类的方式去实例化组件，但内部也通过对象的方式去创建了当前渲染的组件实例。</p>
<p>其次设置组件实例，instance 保留了很多组件相关的数据，维护了组件的上下文，包括对 props、插槽，以及其他实例的属性的初始化处理。</p>
<p><strong>初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中。</strong></p>
<p>首先，是渲染组件生成 subTree，它也是一个 vnode 对象。这里要注意别把 subTree 和 initialVNode 弄混了（其实在 Vue.js 3.0 中，根据命名我们已经能很好地区分它们了，而在 Vue.js 2.x 中它们分别命名为 _vnode 和 $vnode）。我来举个例子说明，在父组件 App 中里引入了 Hello 组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;This is an app.&lt;/p&gt;</span><br><span class="line">    &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在Hello组件中是<code>div</code>标签包裹这一个<code>p</code>标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;p&gt;Hello, Vue 3.0!&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>在 App 组件中， <hello> 节点渲染生成的 vnode ，对应的就是 Hello 组件的 initialVNode ，为了好记，你也可以把它称作“组件 vnode”。而 Hello 组件内部整个 DOM 节点对应的 vnode 就是执行 renderComponentRoot 渲染生成对应的 subTree，我们可以把它称作“子树 vnode”。</p>
<p>我们知道每个组件都会有对应的 render 函数，即使你写 template，也会编译成 render 函数，而 renderComponentRoot 函数就是去执行 render 函数创建整个组件树内部的 vnode，把这个 vnode 再经过内部一层标准化，就得到了该函数的返回结果：子树 vnode。</p>
<p>渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了。</p>
<p>那么我们又再次回到了 patch 函数，会继续对这个子树 vnode 类型进行判断，对于上述例子，App 组件的根节点是 <div> 标签，那么对应的子树 vnode 也是一个普通元素 vnode，那么我们接下来<strong>看对普通 DOM 元素的处理流程</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountElement = <span class="function">(<span class="params">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is)</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isReservedProp(key)) &#123;</span><br><span class="line">        hostPatchProp(el, key, <span class="literal">null</span>, props[key], isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    hostSetElementText(el, vnode.children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况</span></span><br><span class="line">    mountChildren(vnode.children, el, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG &amp;&amp; type !== <span class="string">&#x27;foreignObject&#x27;</span>, optimized || !!vnode.dynamicChildren)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  hostInsert(el, container, anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，挂载元素函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上。</p>
<p>首先是创建 DOM 元素节点，通过 hostCreateElement 方法创建，这是一个平台相关的方法，我们来看一下它在 Web 环境下的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tag, isSVG, is</span>) </span>&#123;</span><br><span class="line">  isSVG ? <span class="built_in">document</span>.createElementNS(svgNS, tag)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(tag, is ? &#123; is &#125; : <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了底层的 DOM API document.createElement 创建元素，所以本质上 Vue.js 强调不去操作 DOM ，只是希望用户不直接碰触 DOM，它并没有什么神奇的魔法，底层还是会操作 DOM。</p>
<p>另外，如果是其他平台比如 Weex，hostCreateElement 方法就不再是操作 DOM ，而是平台相关的 API 了，这些平台相关的方法是在创建渲染器阶段作为参数传入的。</p>
<p>创建完 DOM 节点后，接下来要做的是判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的，这里就不展开讲了。</p>
<p>接下来是对子节点的处理，我们知道 DOM 是一棵树，vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。</p>
<p>如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElementText</span>(<span class="params">el, text</span>) </span>&#123;</span><br><span class="line">  el.textContent = text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。注意，这里有对 child 做预处理的情况（后面编译优化的章节会详细分析）。</p>
<p>可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。</p>
<p>另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/Vue3-0%E7%9A%84%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/Vue3-0%E7%9A%84%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Vue3.0的优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:17:26 / 修改时间：18:17:42" itemprop="dateCreated datePublished" datetime="2021-04-23T18:17:26+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="源码优化"><a href="#源码优化" class="headerlink" title="源码优化"></a>源码优化</h3><p>码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码，这样做的目标是提升自身代码可维护性。</p>
<h4 id="1-更好的代码管理方式：monorepo"><a href="#1-更好的代码管理方式：monorepo" class="headerlink" title="1. 更好的代码管理方式：monorepo"></a>1. 更好的代码管理方式：monorepo</h4><p>首先，源码的优化体现在代码管理方式上。Vue2.x的源码托管在src目录，然后依据功能拆分出了compiler(模版编译的相关代码)、core(与平台无关的通用运行时代码)、platforms(平台专有代码)、sfc(.vue单文件解析相关代码)、shared(共享工具代码)等目录</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/259122/1616574367425-f8002c3a-a103-4d47-a9e7-f0d50673f4e2.png"></p>
<p>而到了 Vue.js 3.0，整个源码是通过monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/259122/1616574492486-577b2ba6-51cf-4765-bcca-aad57864a5e7.png"></p>
<p>可以看出相对于2.x的源码管理方式，monorepo把这些模块拆分到不同的package中，每个package有格子的API、类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p>
<p>另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue.js 使用的，这样用户如果只想使用 Vue.js 3.0 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue.js，减小了引用包的体积大小，而 Vue.js 2 .x 是做不到这一点的。</p>
<h4 id="有类型的javascript：TypeScript"><a href="#有类型的javascript：TypeScript" class="headerlink" title="有类型的javascript：TypeScript"></a>有类型的javascript：TypeScript</h4><p>其次，源码的优化还体现在 Vue.js 3.0 自身采用了 TypeScript 开发。Vue.js 1.x 版本的源码是没有用类型语言的，小右用 JavaScript 开发了整个框架，但对于复杂的框架项目开发，使用类型语言非常有利于代码的维护，因为它可以在编码期间帮你做类型检查，避免一些因类型问题导致的错误；也可以利于它去定义接口的类型，利于 IDE 对变量类型的推导。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>性能优化一直是前端老生常谈的问题。那么对于 Vue.js 2.x 已经足够优秀的前端框架，它的性能优化可以从哪些方面进行突破呢？</p>
<h4 id="1-源码体积优化"><a href="#1-源码体积优化" class="headerlink" title="1. 源码体积优化"></a>1. 源码体积优化</h4><p>首先是源码体积优化，我们在平时工作中也经常会尝试优化静态资源的体积，因为 JavaScript 包体积越小，意味着网络传输时间越短，JavaScript 引擎解析包的速度也越快。</p>
<p>那么，Vue.js 3.0 在源码体积的减少方面做了哪些工作呢？</p>
<ul>
<li>首先，移除一些冷门的 feature（比如 filter、inline-template 等）；</li>
<li>其次，引入 tree-shaking 的技术，减少打包体积。</li>
</ul>
<p>tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记。</p>
<p>举个例子，一个 math 模块定义了 2 个方法 square(x) 和 cube(x) ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这个模块外面只引入了 cube 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span></span><br><span class="line"><span class="comment">// do something with cube</span></span><br></pre></td></tr></table></figure>

<p>最终 math 模块会被 webpack 打包生成如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">/* unused harmony export square */</span></span><br><span class="line">  <span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&#x27;a&#x27;</span>] = cube;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，未被引入的 square 模块被标记了， 然后压缩阶段会利用例如 uglify-js、terser 等压缩工具真正地删除这些没有用到的代码。</p>
<p>也就是说，利用 tree-shaking 技术，如果你在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就不会打包，这样也就间接达到了减少项目引入的 Vue.js 包体积的目的。</p>
<h3 id="2-数据劫持优化"><a href="#2-数据劫持优化" class="headerlink" title="2.数据劫持优化"></a>2.数据劫持优化</h3><p>其次是数据劫持优化。Vue.js区别于React的一大特色是它的数据是响应式的，这个特性从Vue.js 1.x版本就一直伴随着。DOM是数据的一种映射，数据发生变化可以自动更新DOM</p>
<p>在vue内部，想实现这个功能是要付出一定代价的，那就是必须劫持数据的访问和更新。其实这点很好理解，当数据改变后，为了自动更新dom，那么就必须劫持数据的更新，也就是说当数据发生改变后能自动执行一些代码去更新DOM，那么问题来了，Vue怎么知道更新那一片dom？因为在渲染dom的时候访问了数据，我们可以对它进行访问劫持，这样就在内部建立了依赖关系，也就知道对应的dom是什么了。</p>
<p>Vue.js 1.x 和 Vue.js 2.x 内部都是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter，具体是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但这个API有一些缺陷，它必须预先知道要拦截的key是什么，所以它并不能检测对象属性的添加和删除。尽管vue为了解决这个问题提供了$set和$delete实例方法，但是对于用户来说，还是增加了一定的心智负担</p>
<p>另外Object.defineProperty 的方式还有一个问题，举个例子，比如这个嵌套层级比较深的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">      b: &#123;</span><br><span class="line">        c: &#123;</span><br><span class="line">          d: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Vue.js 无法判断你在运行时到底会访问到哪个属性，所以对于这样一个嵌套层级较深的对象，如果要劫持它内部深层次的对象变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的。毫无疑问，如果我们定义的响应式数据过于复杂，这就会有相当大的性能负担。</p>
<p>为了解决上述 2 个问题，Vue.js 3.0 使用了 Proxy API 做数据劫持，它的内部是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>由于它劫持的是整个对象，那么自然对于对象的属性的增加和删除都能检测到。</p>
<p>但要注意的是，Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能，我会在后面分析响应式章节详细介绍它的具体实现原理。</p>
<h3 id="语法-API-优化：Composition-API"><a href="#语法-API-优化：Composition-API" class="headerlink" title="语法 API 优化：Composition API"></a>语法 API 优化：Composition API</h3><p>除了源码和性能方面，Vue.js 3.0 还在语法方面进行了优化，主要是提供了 Composition API</p>
<h4 id="1-优化逻辑组织"><a href="#1-优化逻辑组织" class="headerlink" title="1.优化逻辑组织"></a>1.优化逻辑组织</h4><p>首先，是优化逻辑组织</p>
<p>在 Vue.js 1.x 和 2.x 版本中，编写组件本质就是在编写一个“包含了描述组件选项的对象”，我们把它称为 Options API，它的好处是在于写法非常符合直觉思维，对于新手来说这样很容易理解，这也是很多人喜欢 Vue.js 的原因之一。</p>
<p>Options API 的设计是按照 methods、computed、data、props 这些不同的选项分类，当组件小的时候，这种分类方式一目了然；但是在大型组件中，一个组件可能有多个逻辑关注点，当使用 Options API 的时候，每一个关注点都有自己的 Options，如果需要修改一个逻辑点关注点，就需要在单个文件中不断上下切换和寻找。</p>
<p>Vue.js 3.0 提供了一种新的 API：Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。</p>
<h4 id="2-优化逻辑复用"><a href="#2-优化逻辑复用" class="headerlink" title="2.优化逻辑复用"></a>2.优化逻辑复用</h4><p>其次，是优化逻辑复用</p>
<p>当我们开发项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 Vue.js 2.x 中，我们通常会用 mixins 去复用逻辑，举一个鼠标位置侦听的例子，我们会编写如下函数 mousePositionMixin：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mousePositionMixin = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="built_in">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="built_in">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.x = e.pageX</span><br><span class="line">      <span class="built_in">this</span>.y = e.pageY</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mousePositionMixin</span><br></pre></td></tr></table></figure>

<p>然后在组件中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; &#x2F; y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import mousePositionMixin from &#39;.&#x2F;mouse&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [mousePositionMixin]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。</p>
<p>首先每个 mixin 都可以定义自己的 props、data，它们之间是无感的，所以很容易定义相同的变量，导致命名冲突。另外对组件而言，如果模板中使用不在当前组件中定义的变量，那么就会不太容易知道这些变量在哪里定义的，这就是数据来源不清晰。但是Vue.js 3.0 设计的 Composition API，就很好地帮助我们解决了 mixins 的这两个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;</span><br><span class="line">export default function useMousePosition() &#123;</span><br><span class="line">  const x &#x3D; ref(0)</span><br><span class="line">  const y &#x3D; ref(0)</span><br><span class="line">  const update &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">    x.value &#x3D; e.pageX</span><br><span class="line">    y.value &#x3D; e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(() &#x3D;&gt; &#123;</span><br><span class="line">    window.addEventListener(&#39;mousemove&#39;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(() &#x3D;&gt; &#123;</span><br><span class="line">    window.removeEventListener(&#39;mousemove&#39;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  return &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们约定 useMousePosition 这个函数为 hook 函数，然后在组件中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; &#x2F; y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import useMousePosition from &#39;.&#x2F;mouse&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const &#123; x, y &#125; &#x3D; useMousePosition()</span><br><span class="line">      return &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。</p>
<p>Composition API 除了在逻辑复用方面有优势，也会有更好的类型支持，因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了，不像 Options API 所有的东西使用 this。另外，Composition API 对 tree-shaking 友好，代码也更容易压缩。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/" class="post-title-link" itemprop="url">事件循环：高性能到底是如何做到的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:16:57 / 修改时间：18:17:09" itemprop="dateCreated datePublished" datetime="2021-04-23T18:16:57+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Node-js事件循环"><a href="#Node-js事件循环" class="headerlink" title="Node.js事件循环"></a>Node.js事件循环</h3><p>事件循环同属来说就是一个无限的while循环</p>
<h3 id="Node-js循环原理"><a href="#Node-js循环原理" class="headerlink" title="Node.js循环原理"></a>Node.js循环原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/259122/1616471157971-d43c1f1e-cbb5-4911-b8fb-945b39fc71b5.png"></p>
<p>可以看到，这一流程包含6个阶段，每个阶段代表的含义如下表示:</p>
<ol>
<li>timers: 本阶段已经被 setTimeout() 和 setInterval() 调度的回调函数，简单理解就是由这两个函数启动的回调函数</li>
<li>pending callbacks: 本阶段执行某些系统操作 (如 TCP类型错误)的回调函数</li>
<li>idle、prepare：仅系统内部使用，你只需要知道有这 2 个阶段就可以</li>
<li>poll：检索新的 I/O 事件，执行与 I/O 相关的回调，其他情况 Node.js 将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行，接下来会详细分析这个过程。</li>
<li>check：setImmediate() 回调函数在这里执行，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分，如下代码所示：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 新的事件循环的起点</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate 1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/// 将会在 poll 阶段执行</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./test.conf&#x27;</span>, &#123;<span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;read file success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/// 该部分将会在首次事件循环中执行</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;poll callback&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 首次事件循环执行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这一行代码中又一个非常奇特的地方，就是 setImmediate会在 setTimeout之后输出。有以下几点原因</p>
<ul>
<li>setTimeout如果不设置时间活着设置时间为0，则会默认为1ms</li>
<li>主流程执行完成后，超过1ms时，会将setTimeout回调函数鹿皮插入到代执行poll队列中；</li>
<li>由于当前 <strong>pull队列</strong> 存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行<strong>check：setImmediate</strong>。因此这也验证了这句话，<strong>先执行回调函数，再执行 setImmediate。</strong></li>
<li>close callbacks：执行一些关闭的回调函数，如 socket.on(‘close’, …)。</li>
</ul>
<h4 id="运行七点"><a href="#运行七点" class="headerlink" title="运行七点"></a>运行七点</h4><p>从图一中可以看出事件循环的七点是timers，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在代码 setTimeout 中的回调函数就是新一轮事件循环的起点，看到这里有很多同学会提出非常合理的疑问：“为什么会先输出 2 然后输出 1，不是说 timer 的回调函数是运行起点吗？”</p>
<p>这里有一个非常关键点，当 Node.js 启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的 API、调度定时器，或者 process.nextTick()，然后再开始处理事件循环。因此可以这样理解，Node.js 进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。</p>
<p>总结来说，Node.js 事件循环的发起点有 4 个：</p>
<ul>
<li>Node.js启动后</li>
<li>setTimeout回调函数</li>
<li>setInterval回调函数</li>
<li>也可能是一次I/O后的回调函数</li>
</ul>
<h4 id="Node-js事件循环-1"><a href="#Node-js事件循环-1" class="headerlink" title="Node.js事件循环"></a>Node.js事件循环</h4><p>在上面的核心流程中真正需要关注循环执行的就是 poll 这个过程。在poll过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，异步I/O又分为网络I/O和文件I/O。这是我们常见的代码路基部分的异步回调逻辑</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/259122/1616487208111-0cb279de-37bd-4161-903c-c0a2f6ee698b.png"></p>
<p><strong>微任务和红任务</strong></p>
<p>微任务: 在 node.js 中微任务包含2种 - process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中又其他任务存在时，优先执行微任务队列。并且process.nextTick和promise也存在优先级，process.nextTick高于Promise</p>
<p>宏任务: 在node.js中宏任务包含4种 - setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在统一事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列。这也解析了我们前面提到的第3个问题，事件循环中的事件类型是存在优先级</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/%E8%A7%A3%E6%9E%90-webpack-%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/%E8%A7%A3%E6%9E%90-webpack-%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">解析 webpack 源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:15:21 / 修改时间：18:15:36" itemprop="dateCreated datePublished" datetime="2021-04-23T18:15:21+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虽然 Webpack 看上去无所不能，但从其本质上来说，Webpack 实质就是一个“前端模块打包器”。前端模块打包器做的事情很简单：它帮助开发者将 JavaScript 模块（各种类型的模块化规范）打包为一个或多个 JavaScript 脚本文件。</p>
<p>回到最初起源：前端为什么需要一个模块打包器呢？其实理由很简单：</p>
<ul>
<li>不是所有浏览器都直接支持javascript</li>
<li>前端需要管理依赖脚本，把控不同脚本加载的顺序</li>
<li>前端需要按需加载不同类型的静态资源</li>
</ul>
<p>想想一下，我们的 Web应用有这样一段内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/src/1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/src/2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/src/3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/src/4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/src/5.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/src/6.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个javascript文件都需要额外的HTTP请求获取，并且因为依赖关系，1.js到6.js需要按顺序加载。因此，打包需求应运而生：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意几点：</p>
<ul>
<li>随着HTTP/2技术的推广，未来长远上看，浏览器像上述代码一样发送多个请求不再是性能瓶颈，但目前来看还过于乐观</li>
<li>并不是将所有脚本都打包在一起就是性能最优，<code>/dist/bundle.js</code> 的size一般较大，但这属于另外的 <code>性能优化</code>话题了</li>
</ul>
<p>总之，打包器的需求就是前端“刚需”，实现上述打包需要也并不简单，需要考虑：</p>
<ul>
<li>如何维护不同脚本的打包顺序，保证<code>bundle.js</code>的可用性</li>
<li>如何避免不同脚本、不同模块的命名冲突</li>
<li>在打包过程中，如何确定真正需要的脚本，而不将没有用到的脚本排除在 <code>bundle.js</code> 之外</li>
</ul>
<p>事实上，虽然当前 <code>webpack</code> 依靠loader机制实现了对于不同类型资源的解析和打包，依靠插件机制实现了第三方介入编译构建的过程，但究其本质，webpack只是一个“无所不能”的打包器，实现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.js + b.js + c.js. &#x3D;&gt; bundle.js</span><br></pre></td></tr></table></figure>

<p>为了简化，以ESM模块化规范举例。假设我们有：</p>
<ul>
<li>circle.js模块求圆形面积</li>
<li>square.js模块求正方形面积</li>
<li>app.js模块作为主模块</li>
</ul>
<p>对应内容分别如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// filename: square.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">side</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> side * side;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// filename: app.js</span></span><br><span class="line"><span class="keyword">import</span> squareArea <span class="keyword">from</span> <span class="string">&#x27;./square&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> circleArea <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Area of square: &#x27;</span>, squareArea(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Area of circle&#x27;</span>, circleArea(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>经过 Webpack 打包之后，我们用 <code>bundle.js</code> 来表示 Webpack 处理结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: bundle.js</span></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  <span class="string">&#x27;circle.js&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> PI = <span class="number">3.141</span>;</span><br><span class="line">    <span class="built_in">exports</span>.default = <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;square.js&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">exports</span>.default = <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">side</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;app.js&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> squareArea = <span class="built_in">require</span>(<span class="string">&#x27;square.js&#x27;</span>).default;</span><br><span class="line">    <span class="keyword">const</span> circleArea = <span class="built_in">require</span>(<span class="string">&#x27;circle.js&#x27;</span>).default;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Area of square: &#x27;</span>, squareArea(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Area of circle&#x27;</span>, circleArea(<span class="number">5</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">webpackBundle(&#123;</span><br><span class="line">  modules,</span><br><span class="line">  entry: <span class="string">&#x27;app.js&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如上代码，我们维护了 <code>module</code> 变量，存储了不同模块信息，这个map中，key为模块路径名，value为一个被 wrapped 过的模块函数，我们先称之为 <code>module factory function</code> ， 该函数形如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 模块内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做是为每个模块提供exports和require能力，同时保证了每个模块都处于一个隔离的函数作用域范围。</p>
<p>有了modules变量还不够，我们依赖webpackBundle方法，将所有内容整合在一起。webpackBundle方法接收modules模块信息以及一个入口脚本。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackBundle</span>(<span class="params">&#123; modules, entry &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> moduleCache = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">require</span> = <span class="function"><span class="params">moduleName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经解析并缓存过，直接返回缓存内容</span></span><br><span class="line">    <span class="keyword">if</span> (moduleCache[moduleName]) &#123;</span><br><span class="line">      <span class="keyword">return</span> moduleCache[moduleName];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 这里是为了防止循环引用</span></span><br><span class="line">    moduleCache[moduleName] = <span class="built_in">exports</span>;</span><br><span class="line">    <span class="comment">// 执行模块内容，如果遇见了 require 方法，则继续递归执行 require 方法 </span></span><br><span class="line">    modules[moduleName](<span class="built_in">exports</span>, <span class="built_in">require</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> moduleCache[moduleName];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">require</span>(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动实现打包器"><a href="#手动实现打包器" class="headerlink" title="手动实现打包器"></a>手动实现打包器</h3><p>核心思路如下：</p>
<ol>
<li>读取入口文件 (比如entry.js)</li>
<li>基于AST分析入口文件，并产出依赖列表</li>
<li>使用Babel将相关模块编译到ES5</li>
<li>对每个依赖模块产出一个唯一的ID，方便后续读取模块相关内容</li>
<li>将每个依赖以及经过的Babel编译过后的内容，存储在一个对象中维护</li>
<li>遍历上一步中的对象，构建出一个依赖图</li>
<li>将各模块内容bundle产出</li>
</ol>
<p>首先创建项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir bundler-playground &amp;&amp; cd $_</span><br></pre></td></tr></table></figure>

<p>并启动npm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>安装以下依赖：</p>
<ul>
<li>@babel/parser用于分析源代码，产出 AST；</li>
<li>@babel/traverse用于遍历 AST，找到 import 声明；</li>
<li>@babel/core用于编译，将源代码编译为 ES5；</li>
<li>@babel/preset-env搭配@babel/core使用；</li>
<li>resolve用于获取依赖的绝对路径。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%80%9D%E7%BB%B4%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Choo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Choo'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%80%9D%E7%BB%B4%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/" class="post-title-link" itemprop="url">工程化思维处理方案：如何实现应用主题切换功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 18:14:46 / 修改时间：18:15:01" itemprop="dateCreated datePublished" datetime="2021-04-23T18:14:46+08:00">2021-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在前端基础建设中，样式方案的处理也必不可少</p>
<h3 id="设计一个主题切换工程架构"><a href="#设计一个主题切换工程架构" class="headerlink" title="设计一个主题切换工程架构"></a>设计一个主题切换工程架构</h3><p>随着 iOS 13 引入 Dark Mode（深色模式），各大应用和网站也都开始支持深色模式。相比传统的页面配色方案，深色模式具有较好的降噪性，也能让用户的眼睛看内容更舒适</p>
<h4 id="PostCSS-原理和相关插件能力"><a href="#PostCSS-原理和相关插件能力" class="headerlink" title="PostCSS 原理和相关插件能力"></a>PostCSS 原理和相关插件能力</h4><p>简单来说， PostCSS 是一款编译 CSS 的工具。</p>
<blockquote>
<p>PostCSS is a tool for transforming styles with JS plugins. These plugins can lint your CSS, support variables and mixins, transpile future CSS syntax, inline images, and more.</p>
</blockquote>
<p>如上介绍，postCSS具有良好的插件性，其插件也是使用 javascript 编写的，非常有利于开发者拓展。PostCSS的工作原理：<strong>PostCSS接收一个CSS文件，并提供了插件机制，提供给开发者分析、修改CSS的规则，具体实现方式也是基于AST技术</strong></p>
<h4 id="架构思路总结"><a href="#架构思路总结" class="headerlink" title="架构思路总结"></a>架构思路总结</h4><p>主题切换——社区上介绍的方案往往通过 CSS 变量（CSS 自定义属性）来实现</p>
<p>这无疑是一个很好的思路，但是作为架构来说，使用 CSS 自定义属性——只是其中一个环节。站在更高、更中台化的视觉思考，我们还需要设计：</p>
<ul>
<li>如何维护不同主题色值</li>
<li>谁来维护不同颜色值</li>
<li>研发和设计之间，如何保持不同颜色值的同步沟通</li>
<li>如何最小化前端工程师的开发量，不需要 hard coding 两份颜色数值</li>
<li>如何做到一键切换时的性能最优</li>
<li>如何配合javascript状态管理，同步主题切换的信号</li>
</ul>
<p>基于以上考虑，以一个超链接样式为例，我们希望做到开发时，编写：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">cc</span>(GBK05A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码，就能一劳永逸直接支持两套主题模式。也就是说，在应用编译上，上述代码预期被编译为下面这样的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#646464</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看在编译时，构建环节发生了什么：</p>
<ul>
<li><code>cc(GBK05A)</code> 这样的声明，被编译为<code>#646464</code></li>
<li>也就是说，<code>cc</code> 是一个CSS function，而 <code>GBK05A</code>是一组色值，分别包含了light和dark两种主题的颜色</li>
<li>同时在HTML根节点上，添加属性选择器 <code>data-theme=&#39;dark&#39;</code>，并添加 <code>a</code> 标签color色值样式为 <code>#808080</code></li>
</ul>
<p>我们设想，用户点击“切换主题”按钮时，首先通过 Javascript 将 HTML 根节点标签添加 data-theme 为dark的属性值，这时CSS选择器html[data-theme=’dark’] a 将起作用，实现了样式的切换</p>
<p>结合下图理解：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/259122/1614328790718-2815b58a-248e-4524-af75-851a576659e6.png" alt="描述"></p>
<p>如何在构建时完成 CSS 的样式编译转换呢？答案指向了 PostCSS</p>
<ul>
<li>首先编写一个名为 postcss-theme-colors 的PostCSS插件</li>
<li>维护一个色值，结合上例子就是:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GBK05A: [BK05, BK06]</span><br><span class="line">BK05: <span class="string">&#x27;#808080&#x27;</span></span><br><span class="line">BK06: <span class="string">&#x27;#999999&#x27;</span></span><br></pre></td></tr></table></figure>

<p>postcss-theme-colors需要：</p>
<ol>
<li>识别 <code>cc()</code> 方法</li>
<li>读取色值</li>
<li>通过色值，对 <code>cc()</code> 方法求值，得到两种颜色，分别对应 dark 和 light 模式</li>
<li>原地编译 CSS 中的颜色为 light 模式色值</li>
<li>同时 dark 模式色值写到 HTML 节点上</li>
</ol>
<p>这里需要补充的是，为了将 dark 模式色值按照 html[data-theme=’dark’] 方式写到 HTML 节点上，需要使用另外两个PostCSS插件完成：</p>
<ul>
<li>PostCSS Nested</li>
<li>PostCSS Nesting</li>
</ul>
<p>整体架构设计，总结为下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/259122/1614584969713-a0014b6b-62df-45aa-9be6-19dd959ee910.png" alt="描述"></p>
<h3 id="主题色架构实现"><a href="#主题色架构实现" class="headerlink" title="主题色架构实现"></a>主题色架构实现</h3><h4 id="PostCSS-插件体系"><a href="#PostCSS-插件体系" class="headerlink" title="PostCSS 插件体系"></a>PostCSS 插件体系</h4><p>PostCSS具有天生的插件化体系，开发者一般很容易上手插件开发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postcss = <span class="built_in">require</span>(<span class="string">&#x27;postcss&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = postcss.plugin(<span class="string">&#x27;pluginname&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="comment">// Work with options here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">css, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Transform the CSS AST</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码是一个典型的PostCSS插件编写模版。一个PostCSS就是一个Node.js模块，开发者调用 <code>postcss.plugin</code> 工厂方法返回一个插件实体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    postcssPlugin: <span class="string">&#x27;PLUGIN_NAME&#x27;</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Root (root, postcss) &#123;</span></span><br><span class="line"><span class="comment">      // Transform CSS AST here</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Declaration (decl, postcss) &#123;</span></span><br><span class="line"><span class="comment">      // The faster way to find Declaration node</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Declaration: &#123;</span></span><br><span class="line"><span class="comment">      color: (decl, postcss) &#123;</span></span><br><span class="line"><span class="comment">        // The fastest way find Declaration node if you know property name</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写 PostCSS 插件时，我们可以直接使用postcss.plugin方法完成实际开发。接下来，开始动手实现 postcss-theme-colors。</p>
<h3 id="动手实现postcss-theme-colors"><a href="#动手实现postcss-theme-colors" class="headerlink" title="动手实现postcss-theme-colors"></a>动手实现postcss-theme-colors</h3><p>具体实现逻辑，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">&#x27;postcss&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> defaults = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span>: &#x27;<span class="title">cc</span>&#x27;,</span></span><br><span class="line"><span class="function">  <span class="title">groups</span>: </span>&#123;&#125;,</span><br><span class="line">  colors: &#123;&#125;,</span><br><span class="line">  useCustomProperties: <span class="literal">false</span>,</span><br><span class="line">  darkThemeSelector: <span class="string">&#x27;html[data-theme=&quot;dark&quot;]&#x27;</span>,</span><br><span class="line">  nestingPlugin: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolveColor = <span class="function">(<span class="params">options, theme, group, defaultValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [lightColor, darkColor] = options.groups[group] || []</span><br><span class="line">  <span class="keyword">const</span> color = theme === <span class="string">&#x27;dark&#x27;</span> ? darkColor : lightColor</span><br><span class="line">  <span class="keyword">if</span> (!color) &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (options.useCustomProperties) &#123;</span><br><span class="line">    <span class="keyword">return</span> color.startsWith(<span class="string">&#x27;--&#x27;</span>) ? <span class="string">`var(<span class="subst">$&#123;color&#125;</span>)`</span> : <span class="string">`var(--<span class="subst">$&#123;color&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options.colors[color] || defaultValue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = postcss.plugin(<span class="string">&#x27;postcss-theme-colors&#x27;</span>, <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaults, options)</span><br><span class="line">  <span class="comment">// 获取色值函数（默认为 cc()）</span></span><br><span class="line">  <span class="keyword">const</span> reGroup = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\\b<span class="subst">$&#123;options.<span class="keyword">function</span>&#125;</span>\\(([^)]+)\\)`</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">style, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 PostCSS 工作流程中，是否使用了某些 plugins</span></span><br><span class="line">    <span class="keyword">const</span> hasPlugin = <span class="function"><span class="params">name</span> =&gt;</span></span><br><span class="line">      name.replace(<span class="regexp">/^postcss-/</span>, <span class="string">&#x27;&#x27;</span>) === options.nestingPlugin ||</span><br><span class="line">      result.processor.plugins.some(<span class="function"><span class="params">p</span> =&gt;</span> p.postcssPlugin === name)</span><br><span class="line">    <span class="comment">// 获取最终 CSS 值</span></span><br><span class="line">    <span class="keyword">const</span> getValue = <span class="function">(<span class="params">value, theme</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value.replace(reGroup, <span class="function">(<span class="params">match, group</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resolveColor(options, theme, group, match)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 CSS 声明</span></span><br><span class="line">    style.walkDecls(<span class="function"><span class="params">decl</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = decl.value</span><br><span class="line">      <span class="comment">// 如果不含有色值函数调用，则提前退出</span></span><br><span class="line">      <span class="keyword">if</span> (!value || !reGroup.test(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> lightValue = getValue(value, <span class="string">&#x27;light&#x27;</span>) </span><br><span class="line">      <span class="keyword">const</span> darkValue = getValue(value, <span class="string">&#x27;dark&#x27;</span>) </span><br><span class="line">      <span class="keyword">const</span> darkDecl = decl.clone(&#123;<span class="attr">value</span>: darkValue&#125;)</span><br><span class="line">      <span class="keyword">let</span> darkRule</span><br><span class="line">      <span class="comment">// 使用插件，生成 dark 样式</span></span><br><span class="line">      <span class="keyword">if</span> (hasPlugin(<span class="string">&#x27;postcss-nesting&#x27;</span>)) &#123;</span><br><span class="line">        darkRule = postcss.atRule(&#123;</span><br><span class="line">          name: <span class="string">&#x27;nest&#x27;</span>,</span><br><span class="line">          params: <span class="string">`<span class="subst">$&#123;options.darkThemeSelector&#125;</span> &amp;`</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasPlugin(<span class="string">&#x27;postcss-nested&#x27;</span>)) &#123;</span><br><span class="line">        darkRule = postcss.rule(&#123;</span><br><span class="line">          selector: <span class="string">`<span class="subst">$&#123;options.darkThemeSelector&#125;</span> &amp;`</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decl.warn(result, <span class="string">`Plugin(postcss-nesting or postcss-nested) not found`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加 dark 样式到目标 HTML 节点中</span></span><br><span class="line">      <span class="keyword">if</span> (darkRule) &#123;</span><br><span class="line">        darkRule.append(darkDecl)</span><br><span class="line">        decl.after(darkRule)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> lightDecl = decl.clone(&#123;<span class="attr">value</span>: lightValue&#125;)</span><br><span class="line">      decl.replaceWith(lightDecl)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>理解了这部分源码，使用方式也就呼之欲出了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const colors &#x3D; &#123;</span><br><span class="line">  C01: &#39;#eee&#39;,</span><br><span class="line">  C02: &#39;#111&#39;,</span><br><span class="line">&#125;</span><br><span class="line">const groups &#x3D; &#123;</span><br><span class="line">  G01: [&#39;C01&#39;, &#39;C02&#39;],</span><br><span class="line">&#125;</span><br><span class="line">postcss([</span><br><span class="line">  require(&#39;postcss-theme-colors&#39;)(&#123;colors, groups&#125;),</span><br><span class="line">]).process(css)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Choo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Choo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
